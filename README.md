![img.png](img.png)

### OS 시스템콜해서 논블로킹 구현한 로직이 분명 있을텐데, 어디에 있을까?

NioEventLoop의 private int select(long deadlineNanos)에서 Java NIO의 Selector.select()를 호출한다.
> (Selector.select()는 시스템 콜 하는 부분으로 OS 커널을 통해 NIO를 구현한 부분이다.
> 이런 OS 커널을 통해 구현한 논블로킹은 이벤트를 이벤트 루프 기반의 폴링 메커니즘과 결합해서 비동기 처리를 구현했을 것이다.

++ 궁금증:  대부분 임베디드 서버는 Selector.select()를 사용해서 NIO를 구현했을까..?)

## 네티에 오해했던 부분들
> 스프링 부트 웹플럭스에서 네티 서버를 실행시키면, NioEventLoop는 selct() 메서드를 호출하고, 이 메서드는 네이티브 메서드로 되어있어 OS 커널 시스템콜한다.
> 그리고 요청이 올 때까지 NIO를 통해 select()에서 이벤트를 감지하면, 이벤트 루프는 사용할 수 있는 채널을 찾아서 이벤트 핸들러에게 위임한다.
> 이벤트 핸들러는 이벤트를 처리하고, 이벤트 루프는 다시 이벤트를 감지하러 select()를 호출한다.

### 오해했던 부분
> 이벤트를 받고 처리하는 곳을 설명하는 대부분의 블로그들에서 이벤트 큐를 써놨다.
> NioEventLoop(workerGroup에 속해 있는)가 요청을 처리할 때, 큐에서 꺼내는데 대부분의 블로그들에서 이 큐를 이벤트 큐라고 설명했던 것 같다. 그리고 이벤트 기반 프로그래밍을 도와준다고 설명해있는데,,
> 내가 이해하기론, 이벤트 기반 프로그래밍을 도와주긴 하지만, 이는 inactive 등등의 특정 상황에 따른 이벤트 기반 프로그래밍을 지원해주기는 하나, reactor-netty까지는 넘어와야 좀 더 적합한 말이지 않을까 싶다..! 아직 reactor-netty까지는 보지 못해서 좀 더 공부해봐야 알 것 같다.


