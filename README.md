![img.png](img.png)

### OS 시스템콜해서 논블로킹 구현한 로직이 분명 있을텐데, 어디에 있을까?

NioEventLoop의 private int select(long deadlineNanos)에서 Java NIO의 Selector.select()를 호출한다.
> (Selector.select()는 시스템 콜 하는 부분으로 OS 커널을 통해 NIO를 구현한 부분이다.
> 이런 OS 커널을 통해 구현한 논블로킹은 이벤트를 이벤트 루프 기반의 폴링 메커니즘과 결합해서 비동기 처리를 구현했을 것이다.

++ 궁금증:  대부분 임베디드 서버는 Selector.select()를 사용해서 NIO를 구현했을까..?)

## 네티에 오해했던 부분들
> 스프링 부트 웹플럭스에서 네티 서버를 실행시키면, NioEventLoop는 selct() 메서드를 호출하고, 이 메서드는 네이티브 메서드로 되어있어 OS 커널 시스템콜한다.
> 그리고 요청이 올 때까지 NIO를 통해 select()에서 이벤트를 감지하면, 이벤트 루프는 사용할 수 있는 채널을 찾아서 이벤트 핸들러에게 위임한다.
> 이벤트 핸들러는 이벤트를 처리하고, 이벤트 루프는 다시 이벤트를 감지하러 select()를 호출한다.

### 오해했던 부분
> 이벤트를 받고 처리하는 곳을 설명하는 대부분의 블로그들에서 이벤트 큐를 써놨다.
> 근데 이벤트 큐는 Flux나 Mono에서 사용하는 것이고, 클라이언트에서 요청을 받아 핸들러어뎁터한테 도달하는데 까지는 이벤트 큐를 전혀 사용하지 않는다.
> 이벤트 큐는 Flux나 Mono에서 사용하는 것으로, 대부분의 블로그 설명과는 다소 차이가 있다.


SingleThreadEventExecutor

